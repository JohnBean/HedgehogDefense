;libCombatModel
;  Variables and procedures specific to the combat model

globals [
  ;Tables of historical values
  SystemRanges
  
  ; Variables used in the calculation of the combat model
  cm_coeffs
]

directed-link-breed [ directFiring directFire ]
directed-link-breed [ indirectFiring indirectFire ]

to setup-CombatModel
  ;Contains effective ranges (in meters) for the system types
  ;  Note: these are average effective ranges to hit - penetration et al. are included in Lanchester constants
  ;  (Infantry, Tanks, AT, Artillery)
  set SystemRanges [ [350 500 700 8500]
                     [400 550 700 8500] ]
  
  ;Turkes linear Lanchester numbers, derived from Battle of Kursk
  ;  Soviet (aka French) and German, respectively
  ;  set cm_coeffs [ .0000000268 .0000000668 ]
  set cm_coeffs [ .000000268 .000000668 ]     ; scaled up, to approx 30% attrition in 60 hours for an even brigade-on-brigade action
end

;This turtle marks the nearest enemy as either the direct or indirect (out of direct range) target it wants to engage
to cm_declareTarget
  let opponent c_nearestEnemy
  if (opponent = nobody) [stop]
  ifelse (distance opponent <= curDRange) [
    create-directFire-to opponent
  ] [
    if (distance opponent <= curIRange) [ create-indirectFire-to opponent ]
  ]
end

;This turtle attrits its target (if any), as well as any turtles directly attacking it
;  NOTE: this should only be called after all turtles have declared their targets
;  IMPLEMENTATION: this adds a portion of this turtle's strength to each opponent's enemyStrength variable
to cm_attritTargets
  let indirectOnly false
  
  ;Set opponents to be my direct target + anyone directly attacking me
  let opponents (turtle-set in-directFire-neighbors out-directFire-neighbors)

  ;If no direct targets and no one directly attacking me,
  ;  then set indirectOnly flag and my opponent to be my indirect target
  if (count opponents = 0) [
    set indirectOnly true
    set opponents out-indirectFire-neighbors
  ]
  
  ;If no targets at all, no need to calculate attrition
  if (count opponents = 0) [stop]
  
  ;
  ifelse (not indirectOnly) [
    ;Calculate my and the total enemy strengths
    let attriterStrength cm_reportDirStrength self
    let totalOppStrength 0
    ask opponents [ set totalOppStrength (totalOppStrength + cm_reportDirStrength self) ]
    
    ;Apportion the attrition I can deal, across all opponents, proportionally to each according to their strength
    ask opponents [
      ;this opponent's strength as a proportion of the total
      let toThisOpponent (cm_reportDirStrength self / totalOppStrength)

      set enemyStrength (enemyStrength + (attriterStrength * toThisOpponent))
    ]    
  ] [
    if (count opponents > 1) [error "libCombatModel: indirectOnly = true, but I have more than one opponent"]        ;DEBUG

    ;Only use my artillery strength
    let attriterStrength cm_reportIndStrength self    
    ask opponents [set enemyStrength (enemyStrength + attriterStrength)]
  ]
end

;This turtle applies attrition to itself
;  IMPLEMENTATIONand updates its effectiveness, using its current enemyStrength value
to cm_realizeAttrition
  let oppCoeff 0
  ifelse (allegiance = GERMAN) [
    set oppCoeff (item FRENCH cm_coeffs)
  ] [
    set oppCoeff (item GERMAN cm_coeffs)
  ]
  let myStrength cm_reportDirStrength self
  
  ;Lanchester Linear model
  let attrition (1 - oppCoeff * enemyStrength)
  cm_allocateAttrition attrition
  
  ;Reset the strength directed towards me
  set enemyStrength 0
end

;----------------------------------------------
;==          UTILITY FUNCTIONS               ==
;----------------------------------------------

to-report cm_reportDirStrength [ unit ]
  report ([curInf] of unit) + (10 * [curAT] of unit) + (20 * [curTanks] of unit) + (40 * [curArt] of unit)
end

to-report cm_reportIndStrength [ unit ]
  report (40 * [curArt] of unit)
end

to-report cm_reportMaxStrength [ unit ]
  report ([startInf] of unit) + (10 * [startAT] of unit) + (20 * [startTanks] of unit) + (40 * [startArt] of unit)
end

;Proportionally allocates this turtle's attrition to the various combat systems (deterministic)
;  NOTE: input is attrition as a percentage (that is, newStrength / oldStrength)
;  IMPLEMENTATION: also updates the turtle's effectiveness value and sets triggers for Phil's code
to cm_allocateAttrition [ attrition ]
  set curInf (curInf * attrition)
  set curAT (curAT * attrition)
  set curTanks (curTanks * attrition)
  set curArt (curArt * attrition)
  
  set effectiveness (cm_reportDirStrength self / cm_reportMaxStrength self)
  
  ;FIXME hack on retreat behavior
  if (allegiance = FRENCH) [
    if (effectiveness <= 0.7) [
      set state s_RETREAT
      set retreatState 1
    ]
    if (effectiveness <= 0.5) [
      set retreatState 2
    ]
    if (effectiveness <= 0.3) [
      set retreatState 3
    ]
  ]
end