;libBridgeModel
;  Variables and procedures specific to the bridge crossing model

globals [  
  ; Variables used in bridge crossing
  numBridges;How many bridgeheads wide the crossing is

  ;;staging areas
  chStagingX;;the channel bridge
  chStagingY
  chX
  chY
  chCrossed
   
  abStagingX
  abStagingY
  abX
  abY
  abCrossed
  
  amStagingX
  amStagingY
  amX
  amY
  amCrossed
  
  brStagingX
  brStagingY
  brX
  brY
  brCrossed
  
  peStagingX
  peStagingY
  peX
  peY
  peCrossed
]

to setup-BridgeModel
  set chStagingX array:from-list[135 133 137 131 139 129 141 127 143 125 145]
  set chStagingY array:from-list[490 492 488 494 486 496 484 498 482 500 480]
  set abStagingX array:from-list[185 187 183 189 181 191 179 193 177 195 175]
  set abStagingY array:from-list[458 456 460 454 462 452 464 450 466 448 468]
  set amStagingX array:from-list[366 368 364 370 362 372 360 374 358 376 356]
  set amStagingY array:from-list[342 340 344 338 346 336 348 334 350 332 352]
  set brStagingX array:from-list[526 528 524 530 522 532 520 534 518 536 516]
  set brStagingY array:from-list[364 366 362 368 360 370 358 372 356 374 354]
  set peStagingX array:from-list[596 598 594 600 592 602 590 604 588 606 586]
  set peStagingY array:from-list[352 350 354 348 356 346 358 344 360 342 362]
  set chX 128
  set chY 483
  set abX 173;the position accross the abevile bridge units will move to
  set abY 450
  set amX 357
  set amY 336
  set brX 528
  set brY 342
  set peX 586
  set peY 346
  set numBridges 1
end

to setup-bridge-sliders
  ;this ensures that the sliders total 212
  ;setting the Channel bridge slider to max - the toal of the other ensures we always have at least 212,
  set crossingChannel 212 - crossingAbbeville - crossingAmiens - crossingPeronne - crossingBray 
  ;the rest ensures we don't have over
  if(crossingChannel < 0)[
    ;if there are too many troops which cause the set channel above to go negative 
    ;we remove from this and the adjacent bridge to fix it
    set crossingAbbeville crossingAbbeville + crossingChannel
    set crossingChannel 0
  ]
  if(crossingAbbeville < 0)[
    ;if this caused Abbevile to go negative as well this process continues
    ;until we assure all of the sliders are placed in such a way that there can't be too many brigades
    set crossingAmiens crossingAmiens + crossingAbbeville
    set crossingAbbeville 0
  ]
  if(crossingAmiens < 0)[
    set crossingBray crossingBray + crossingAmiens
    set crossingAmiens 0
  ]
end

to place-germans
  random-seed 500 + who
  ifelse(who < crossingChannel)[
    set targetBridge 1
      setxy 140 + random 40 510 + random 40
  ][
  ifelse(who < crossingChannel + crossingAbbeville)[
    set targetBridge 2
      setxy 195 + random 60 475 + random 60
  ][
  ifelse(who < crossingChannel + crossingAbbeville + crossingAmiens)[
    set targetBridge 3
    setxy 347 + random 60 368 + random 60
  ][
  ifelse(who < crossingChannel + crossingAbbeville + crossingAmiens + crossingBray)[
   set targetBridge 4
     setxy 468 + random 40 382 + random 40
  ][
  set targetBridge 5
  setxy 552 + random 45 391 + random 45
  ]
  ]]]
end

to selectBridge
  if (state = 1 and allegiance = GERMAN) [    ; if brigade is german and ready for orders
    let i 0                                   ; the counter that determines what spot we are currently looking to fill
    let valid 1                               ;a check for if the spot we're looking at is valid for this brigade
    ;find the nearest empty waiting spot to fill in at
    let curBridge targetBridge
    repeat count turtles with[targetBridge = curBridge][
      set valid 1                             ;assume the spot we're looking at is valid until proven otherwise
      if((i < destinationNum and i > -1) or destinationNum = -1)[;if this brigade hasn't chosen a spot yet have them look for one
        ;;what row of the formation are we looking at?
        let row floor (i / 11)
        
        ;;this handles units looking to cross the abbevile bridge
        if(targetBridge = 1)[
          ;this isn' a valid spot if someone else is going to use it
          if(any? units with[destinationNum = i and targetBridge = 1 and allegiance = GERMAN])[
            set valid 0
          ]
          ;the spot is not valid if it is farther from the bridge than the current destination
          if(i > destinationNum and destinationNum > -1)[
            set valid 0
          ]
          if(valid = 1)[
            ;find the location of this destination by finding the base location and shifting by the row it's in
            let goalX ((array:item chStagingX (i - (11 * row))) + (row * 2))
            let goalY ((array:item chStagingY (i - (11 * row))) + (row * 2))
            let myDistance sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor)))
            ;we are setting this brigade to move to destination i, no others can move here now
            if not(any? units with[targetBridge = 1 and allegiance = GERMAN and (destinationNum > i + 1 or destinationNum = -1) and sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor))) < myDistance])[
              ;we are setting this brigade to move to destination i, no others can move here now
              set destinationNum i
              set destinationX goalX
              set destinationY goalY
              set state 2
              stop
            ]
          ]
        ]
        ;;this handles units looking to cross the abbevile bridge
        if(targetBridge = 2)[
          ;this isn' a valid spot if someone else is going to use it
          if(any? units with[destinationNum = i and targetBridge = 2 and allegiance = GERMAN])[
            set valid 0
          ]
          ;the spot is not valid if it is farther from the bridge than the current destination
          if(i > destinationNum and destinationNum > -1)[
            set valid 0
          ]
          if(valid = 1)[
            ;find the location of this destination by finding the base location and shifting by the row it's in
            let goalX ((array:item abStagingX (i - (11 * row))) + (row * 2))
            let goalY ((array:item abStagingY (i - (11 * row))) + (row * 2))
            let myDistance sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor)))
             if not(any? units with[targetBridge = 2 and allegiance = GERMAN and (destinationNum > i + 1 or destinationNum = -1) and sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor))) < myDistance])[
               ;we are setting this brigade to move to destination i, no others can move here now
               set destinationNum i
               set destinationX goalX
               set destinationY goalY
               set state 2
               stop
             ]
          ]
        ]
        ;;this handles units looking to cross the abbevile bridge
        if(targetBridge = 3)[
          ;this isn' a valid spot if someone else is going to use it
          if(any? units with[destinationNum = i and targetBridge = 3 and allegiance = GERMAN])[
            set valid 0
          ]
          ;the spot is not valid if it is farther from the bridge than the current destination
          if(i > destinationNum and destinationNum > -1)[
            set valid 0
          ]
          if(valid = 1)[
            ;find the location of this destination by finding the base location and shifting by the row it's in
            let goalX ((array:item amStagingX (i - (11 * row))) + (row * 2))
            let goalY ((array:item amStagingY (i - (11 * row))) + (row * 2))
            let myDistance sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor)))
            if not(any? units with[targetBridge = 3 and allegiance = GERMAN and (destinationNum > i + 1 or destinationNum = -1) and sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor))) < myDistance])[
              ;we are setting this brigade to move to destination i, no others can move here now
              set destinationNum i
              set destinationX goalX
              set destinationY goalY
              set state 2
              stop
            ]
          ]
        ]
        if(targetBridge = 4)[       
          ;this isn' a valid spot if someone else is going to use it
          if(any? units with[destinationNum = i and targetBridge = 4 and allegiance = GERMAN])[
            set valid 0
          ]
          ;the spot is not valid if it is farther from the bridge than the current destination
          if(i > destinationNum and destinationNum > -1)[
            set valid 0
          ]
          if(valid = 1)[
            ;find the location of this destination by finding the base location and shifting by the row it's in
            let goalX ((array:item brStagingX (i - (11 * row))) + (row * -2))
            let goalY ((array:item brStagingY (i - (11 * row))) + (row * 2))
            let myDistance sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor)))
            ;we are setting this brigade to move to destination i, no others can move here now
            if not(any? units with[targetBridge = 4 and allegiance = GERMAN and (destinationNum > i + 1 or destinationNum = -1) and sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor))) < myDistance])[
              set destinationNum i
              set destinationX goalX
              set destinationY goalY
              set state 2
              stop
            ]
          ]
        ]
        if(targetBridge = 5)[
          
          ;this isn' a valid spot if someone else is going to use it
          if(any? units with[destinationNum = i and targetBridge = 5 and allegiance = GERMAN])[
            set valid 0
          ]
          ;the spot is not valid if it is farther from the bridge than the current destination
          if(i > destinationNum and destinationNum > -1)[
            set valid 0
          ]
          ;this isn't a valid spot if a closer brigade needs to move toward it
          if(valid = 1)[
            ;we are setting this brigade to move to destination i, no others can move here now
            ;find the location of this destination by finding the base location and shifting by the row it's in
            let goalX ((array:item peStagingX (i - (11 * row))) + (row * 2))
            let goalY ((array:item peStagingY (i - (11 * row))) + (row * 2))
            let myDistance sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor)))
            if not(any? units with[targetBridge = 5 and allegiance = GERMAN and (destinationNum > i + 1 or destinationNum = -1) and sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor))) < myDistance])[
              set destinationNum i
              set destinationX goalX
              set destinationY goalY
              set state 2
              stop
            ]
          ]
        ]
      ]
      set i (i + 1);;after we've looked at a spot incriment so we can look at the next one on the next pass
    ]
  ]
  if(state = 1 and allegiance = GERMAN and destinationNum = -1)[
    ifelse(targetBridge = 1)[
      set destinationX 146
      set destinationY 501
    ]
    [
    ifelse(targetBridge = 2)[
      set destinationX 194
      set destinationY 470
    ]
    [
    ifelse(targetBridge = 3)[
      set destinationX 364
      set destinationY 352
    ]
    [
    ifelse(targetBridge = 4)[
      set destinationX 515
      set destinationY 371
    ]
    [
    if(targetBridge = 5)[
      set destinationX 601
      set destinationY 364
    ]]]]]
  ]
  
end

to crossBridge
  ;move to a relay point if unable to find a specific destination
  if (state = 1 and allegiance = GERMAN and destinationX > -1)[
    if(destinationNum = -1)[
      facexy destinationX destinationY
      jump curSpeed
    ]
    if(destinationNum = 0 )[
      let curTarget targetBridge
      if not(any? turtles with[allegiance = GERMAN and targetBridge = curTarget and state = 3])[
       set state 3 
      ] 
    ]
  ]
  
  ;if the nazi brigade is stationary and ready for orders
  if (state = 2 ) [;if the unit is moving toward a waiting position go toward it until it's too close to move farther
    ifelse(abs (destinationX - xcor) < curSpeed and abs (destinationY - ycor) < curSpeed)[
      ;if the unit reached its waiting position face the enemies and set its state to ready to move
      setxy destinationX destinationY
      set state 1
      facexy 170 450
    ] [
      ;; show "trying to move"
      ;if it hasn't reached its waiting point move toward it at its normal speed
      facexy destinationX destinationY
      jump curSpeed
    ]
  ]
  if (state = 3 and allegiance = GERMAN) [ ; if german and currently crossing the bridge
    set destinationNum -1
     if (targetBridge = 1) [
       set chCrossed chCrossed + (60 * numBridges)
       setxy (array:item chStagingX 0) - ((array:item chStagingX 0 - chX) * (chCrossed /(curInf + curAT + curTanks + curArt))) array:item chStagingY 0 - ((array:item chStagingY 0 - chY) * (chCrossed /(curInf + curAT + curTanks + curArt)))
    ;   jump 1
       if(xcor <= chX and ycor <= chY)[
         set state 4
         set chCrossed 0
         set destinationNum -1
       ]
     ]
     if (targetBridge = 2) [
       set abCrossed abCrossed + (60 * numBridges)
       setxy (array:item abStagingX 0) - ((array:item abStagingX 0 - abX) * (abCrossed /(curInf + curAT + curTanks + curArt))) array:item abStagingY 0 - ((array:item abStagingY 0 - abY) * (abCrossed /(curInf + curAT + curTanks + curArt)))
   ;    jump 1
       if(xcor <= abX and ycor <= abY)[
         set state 4
         set abCrossed 0
         set destinationNum -1
       ]
     ] 
     if (targetBridge = 3) [
       set amCrossed amCrossed + (60 * numBridges)
       setxy (array:item amStagingX 0) - ((array:item amStagingX 0 - amX) * (amCrossed /(curInf + curAT + curTanks + curArt))) array:item amStagingY 0 - ((array:item amStagingY 0 - amY) * (amCrossed /(curInf + curAT + curTanks + curArt)))
  ;     jump 1
       if(xcor <= amX and ycor <= amY)[
         set state 4
         set amCrossed 0
         set destinationNum -1
       ]
     ]
     if(targetBridge = 4)[
       set brCrossed brCrossed + (60 * numBridges)
     ;  setxy (array:item amStagingX 0) - ((array:item amStagingX 0 - amX) * (amCrossed /(curInf + curAT + curTanks + curArt))) array:item amStagingY 0 - ((array:item amStagingY 0 - amY) * (amCrossed /(curInf + curAT + curTanks + curArt)))
       setxy (array:item brStagingX 0) - ((array:item brStagingX 0 - brX) * (brCrossed /(curInf + curAT + curTanks + curArt))) (array:item brStagingY 0) - ((array:item brStagingY 0 - brY) * (brCrossed /(curInf + curAT + curTanks + curArt)))
      
 ;      jump 1
       if(ycor <= brY)[
         set state 4
         set brCrossed 0
         set destinationNum -1
       ]
     ] 
     if(targetBridge = 5)[
       set peCrossed peCrossed + (60 * numBridges)
       setxy (array:item peStagingX 0) - ((array:item peStagingX 0 - peX) * (peCrossed /(curInf + curAT + curTanks + curArt))) array:item peStagingY 0 - ((array:item peStagingY 0 - peY) * (peCrossed /(curInf + curAT + curTanks + curArt)))
;       jump 1
       if(xcor <= peX and ycor <= peY)[
         set state 5
         set peCrossed 0
         set destinationNum -1
       ]
     ]
  ]
end