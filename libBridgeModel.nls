;libBridgeModel
;  Variables and procedures specific to the bridge crossing model

globals [
  ;Macros
  bm_CHANNEL
  bm_ABBEVILLE
  bm_AMIENS
  bm_BRAY
  bm_PERONNE
  
  ; Variables used in bridge crossing
;  bm_bridges
  bm_stagingAreas
   ;;staging areas
  chStagingX;;the channel bridge
  chStagingY
  chX
  chY
  chCrossed
   
  abStagingX
  abStagingY
  abX
  abY
  abCrossed
  
  amStagingX
  amStagingY
  amX
  amY
  amCrossed
  
  brStagingX;;bracer
  brStagingY
  brX
  brY
  brCrossed
  
  peStagingX
  peStagingY
  peX
  peY
  peCrossed
]

to setup-BridgeModel
  ;Macros
  ;set bm_CHANNEL 0
 ; set bm_ABBEVILLE 1
 ; set bm_AMIENS 2
  ;set bm_BRAY 3
 ; set bm_PERONNE 4
  
  ;XY bridge coordinates
  ; Channel, Abbeville, Amiens, Bray, Peronne
 ; set bm_bridges [[128 483]
 ;                 [173 450]
 ;                 [357 336]
 ;                 [528 342]
 ;                 [586 346]]
  ;XY staging coordinates, same order
 ; set bm_stagingAreas [[151 508]
  ;                     [200 427]
  ;                     [372 367]
  ;                     [511 379]
  ;                     [592 383]]
  
  set chStagingX array:from-list[135 133 137 131 139 129 141 127 143 125 145]
  set chStagingY array:from-list[490 492 488 494 486 496 484 498 482 500 480]
  set abStagingX array:from-list[185 187 183 189 181 191 179 193 177 195 175]
  set abStagingY array:from-list[458 456 460 454 462 452 464 450 466 448 468]
  set amStagingX array:from-list[366 368 364 370 362 372 360 374 358 376 356]
  set amStagingY array:from-list[342 340 344 338 346 336 348 334 350 332 352]
  set brStagingX array:from-list[526 528 524 530 522 532 520 534 518 536 516]
  set brStagingY array:from-list[364 366 362 368 360 370 358 372 356 374 354]
  set peStagingX array:from-list[596 598 594 600 592 602 590 604 588 606 586]
  set peStagingY array:from-list[352 350 354 348 356 346 358 344 360 342 362]
  set chX 128
  set chY 483
  set abX 173;the position accross the abevile bridge units will move to
  set abY 450
  set amX 357
  set amY 336
  set brX 528
  set brY 342
  set peX 586
  set peY 346
end

to selectBridge
  if (state = 1 and allegiance = GERMAN) [    ; if brigade is german and ready for orders
    let i 0                                   ; the counter that determines what spot we are currently looking to fill
    let goal -1                               ; a marker for wether or not this brigade has chosen a spot to fill
    let valid 1                               ;a check for if the spot we're looking at is valid for this brigade

    ;find the nearest empty waiting spot to fill in at
    let curBridge targetBridge
    repeat count turtles with[targetBridge = curBridge][
      set valid 1                             ;assume the spot we're looking at is valid until proven otherwise
      if(goal = -1)[                          ;if this brigade hasn't chosen a spot yet have them look for one
                                               ;;what row of the formation are we looking at?
        let row 0
        ifelse(i > 10 and i < 22)[
          set row 1
        ]
        [
        ifelse(i > 21 and i < 33)[
          set row 2
        ]
        [
        ifelse(i > 32 and i < 44)[
          set row 3
        ]
        [
        ifelse(i > 43 and i < 55)[
          set row 4
        ]
        [
        ifelse(i > 54 and i < 66)[
          set row 5
        ]
        [
        ifelse(i > 65 and i < 77)[
          set row 6
        ]
        [
        ifelse(i > 76 and i < 88)[
          set row 7
        ]
        [
        if(i > 87 and i < 99)[
          set row 8
        ]]]]]]]] 
        
        ;;this handles units looking to cross the abbevile bridge
        if(targetBridge = 1)[
          ;this isn' a valid spot if someone else is going to use it
          if(any? units with[destinationNum = i and targetBridge = 1 and allegiance = GERMAN])[
            set valid 0
          ]
          ;the spot is not valid if it is farther from the bridge than the current destination
          if(i > destinationNum and destinationNum > -1)[
            set valid 0
          ]
          if(valid = 1)[
            ;find the location of this destination by finding the base location and shifting by the row it's in
            let goalX ((array:item chStagingX (i - (11 * row))) + (row * 2))
            let goalY ((array:item chStagingY (i - (11 * row))) + (row * 2))
            let myDistance sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor)))
            ;we are setting this brigade to move to destination i, no others can move here now
            if not(any? units with[targetBridge = 1 and allegiance = GERMAN and (destinationNum > i + 1 or destinationNum = -1) and sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor))) < myDistance])[
          
              set destinationNum i
              set destinationX goalX
              set destinationY goalY
              set state 2
              set goal 1
              stop
            ]
          ]
        ]
        ;;this handles units looking to cross the abbevile bridge
        if(targetBridge = 2)[
          ;this isn' a valid spot if someone else is going to use it
          if(any? units with[destinationNum = i and targetBridge = 2 and allegiance = GERMAN])[
            set valid 0
          ]
          ;the spot is not valid if it is farther from the bridge than the current destination
          if(i > destinationNum and destinationNum > -1)[
            set valid 0
          ]
          if(valid = 1)[
            ;find the location of this destination by finding the base location and shifting by the row it's in
            let goalX ((array:item abStagingX (i - (11 * row))) + (row * 2))
            let goalY ((array:item abStagingY (i - (11 * row))) + (row * 2))
            let myDistance sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor)))
             if not(any? units with[targetBridge = 2 and allegiance = GERMAN and (destinationNum > i + 1 or destinationNum = -1) and sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor))) < myDistance])[
               ;we are setting this brigade to move to destination i, no others can move here now
               set destinationNum i
               set destinationX goalX
               set destinationY goalY
               set state 2
               set goal 1
               stop
             ]
          ]
        ]
        ;;this handles units looking to cross the abbevile bridge
        if(targetBridge = 3)[
          ;this isn' a valid spot if someone else is going to use it
          if(any? units with[destinationNum = i and targetBridge = 3 and allegiance = GERMAN])[
            set valid 0
          ]
          ;the spot is not valid if it is farther from the bridge than the current destination
          if(i > destinationNum and destinationNum > -1)[
            set valid 0
          ]
          if(valid = 1)[
            ;find the location of this destination by finding the base location and shifting by the row it's in
            let goalX ((array:item amStagingX (i - (11 * row))) + (row * 2))
            let goalY ((array:item amStagingY (i - (11 * row))) + (row * 2))
            let myDistance sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor)))
            if not(any? units with[targetBridge = 3 and allegiance = GERMAN and (destinationNum > i + 1 or destinationNum = -1) and sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor))) < myDistance])[
              ;we are setting this brigade to move to destination i, no others can move here now
              set destinationNum i
              set destinationX goalX
              set destinationY goalY
              set state 2
              set goal 1
              stop
            ]
          ]
        ]
        if(targetBridge = 4)[       
          ;this isn' a valid spot if someone else is going to use it
          if(any? units with[destinationNum = i and targetBridge = 4 and allegiance = GERMAN])[
            set valid 0
          ]
          ;the spot is not valid if it is farther from the bridge than the current destination
          if(i > destinationNum and destinationNum > -1)[
            set valid 0
          ]
          if(valid = 1)[
            ;find the location of this destination by finding the base location and shifting by the row it's in
            let goalX ((array:item brStagingX (i - (11 * row))) + (row * -2))
            let goalY ((array:item brStagingY (i - (11 * row))) + (row * 2))
            let myDistance sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor)))
            ;we are setting this brigade to move to destination i, no others can move here now
            if not(any? units with[targetBridge = 4 and allegiance = GERMAN and (destinationNum > i + 1 or destinationNum = -1) and sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor))) < myDistance])[
              set destinationNum i
              set destinationX goalX
              set destinationY goalY
              set state 2
              set goal 1
              stop
            ]
          ]
        ]
        if(targetBridge = 5)[
          
          ;this isn' a valid spot if someone else is going to use it
          if(any? units with[destinationNum = i and targetBridge = 5 and allegiance = GERMAN])[
            set valid 0
          ]
          ;the spot is not valid if it is farther from the bridge than the current destination
          if(i > destinationNum and destinationNum > -1)[
            set valid 0
          ]
          ;this isn't a valid spot if a closer brigade needs to move toward it
          if(valid = 1)[
            ;we are setting this brigade to move to destination i, no others can move here now
            ;find the location of this destination by finding the base location and shifting by the row it's in
            let goalX ((array:item peStagingX (i - (11 * row))) + (row * 2))
            let goalY ((array:item peStagingY (i - (11 * row))) + (row * 2))
            let myDistance sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor)))
            if not(any? units with[targetBridge = 5 and allegiance = GERMAN and (destinationNum > i + 1 or destinationNum = -1) and sqrt((abs(goalX - xcor) * abs(goalX - xcor)) + (abs(goalY - ycor) * abs(goalY - ycor))) < myDistance])[
              set destinationNum i
              set destinationX goalX
              set destinationY goalY
              set state 2
              set goal 1
              stop
            ]
          ]
        ]
      ]
      set i (i + 1);;after we've looked at a spot incriment so we can look at the next one on the next pass
    ]
  ]
  if(state = 1 and allegiance = GERMAN and destinationNum = -1)[
    ifelse(targetBridge = 1)[
      set destinationX 146
      set destinationY 501
    ]
    [
    ifelse(targetBridge = 2)[
      set destinationX 194
      set destinationY 470
    ]
    [
    ifelse(targetBridge = 3)[
      set destinationX 364
      set destinationY 352
    ]
    [
    ifelse(targetBridge = 4)[
      set destinationX 515
      set destinationY 371
    ]
    [
    if(targetBridge = 5)[
      set destinationX 601
      set destinationY 364
    ]]]]]
  ]
  
end

to crossBridge
  ;move to a relay point if unable to find a specific destination
  if (state = 1 and allegiance = GERMAN and destinationX > -1)[
    if(destinationNum = -1)[
      facexy destinationX destinationY
      jump curSpeed
    ]
    if(destinationNum = 0 )[
      let curTarget targetBridge
      if not(any? turtles with[allegiance = GERMAN and targetBridge = curTarget and state = 3])[
       set state 3 
      ] 
    ]
  ]
  
  ;if the nazi brigade is stationary and ready for orders
  if (state = 2 ) [;if the unit is moving toward a waiting position go toward it until it's too close to move farther
    ifelse(abs (destinationX - xcor) < curSpeed and abs (destinationY - ycor) < curSpeed)[
      ;if the unit reached its waiting position face the enemies and set its state to ready to move
      setxy destinationX destinationY
      set state 1
      facexy 170 450
    ] [
      ;; show "trying to move"
      ;if it hasn't reached its waiting point move toward it at its normal speed
      facexy destinationX destinationY
      jump curSpeed
    ]
  ]
  if (state = 3 and allegiance = GERMAN) [ ; if german and currently crossing the bridge
    set destinationNum -1
     if (targetBridge = 1) [
       set chCrossed chCrossed + 60
       setxy (array:item chStagingX 0) - ((array:item chStagingX 0 - chX) * (chCrossed /(curInf + curAT + curTanks + curArt))) array:item chStagingY 0 - ((array:item chStagingY 0 - chY) * (chCrossed /(curInf + curAT + curTanks + curArt)))
    ;   jump 1
       if(xcor <= chX and ycor <= chY)[
         set state 4
         set chCrossed 0
         set destinationNum -1
       ]
     ]
     if (targetBridge = 2) [
       set abCrossed abCrossed + 60
       setxy (array:item abStagingX 0) - ((array:item abStagingX 0 - abX) * (abCrossed /(curInf + curAT + curTanks + curArt))) array:item abStagingY 0 - ((array:item abStagingY 0 - abY) * (abCrossed /(curInf + curAT + curTanks + curArt)))
   ;    jump 1
       if(xcor <= abX and ycor <= abY)[
         set state 4
         set abCrossed 0
         set destinationNum -1
       ]
     ] 
     if (targetBridge = 3) [
       set amCrossed amCrossed + 60
       setxy (array:item amStagingX 0) - ((array:item amStagingX 0 - amX) * (amCrossed /(curInf + curAT + curTanks + curArt))) array:item amStagingY 0 - ((array:item amStagingY 0 - amY) * (amCrossed /(curInf + curAT + curTanks + curArt)))
  ;     jump 1
       if(xcor <= amX and ycor <= amY)[
         set state 4
         set amCrossed 0
         set destinationNum -1
       ]
     ]
     if(targetBridge = 4)[
       set brCrossed brCrossed + 60
     ;  setxy (array:item amStagingX 0) - ((array:item amStagingX 0 - amX) * (amCrossed /(curInf + curAT + curTanks + curArt))) array:item amStagingY 0 - ((array:item amStagingY 0 - amY) * (amCrossed /(curInf + curAT + curTanks + curArt)))
       setxy (array:item brStagingX 0) - ((array:item brStagingX 0 - brX) * (brCrossed /(curInf + curAT + curTanks + curArt))) (array:item brStagingY 0) - ((array:item brStagingY 0 - brY) * (brCrossed /(curInf + curAT + curTanks + curArt)))
      
 ;      jump 1
       if(ycor <= brY)[
         set state 4
         set brCrossed 0
         set destinationNum -1
       ]
     ] 
     if(targetBridge = 5)[
       set peCrossed peCrossed + 60
       setxy (array:item peStagingX 0) - ((array:item peStagingX 0 - peX) * (peCrossed /(curInf + curAT + curTanks + curArt))) array:item peStagingY 0 - ((array:item peStagingY 0 - peY) * (peCrossed /(curInf + curAT + curTanks + curArt)))
;       jump 1
       if(xcor <= peX and ycor <= peY)[
         set state 5
         set peCrossed 0
         set destinationNum -1
       ]
     ]
  ]
end